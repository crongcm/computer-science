# Operating system

## 어플리케이션
    
- 어플리케이션 : 일반 사용자가 사용할 기능을 제공하는 컴퓨터가 실행할 수 있는 명령어들의 집합
- 메모리 : 실행된 애플리케이션이 상주하는 곳 
- CPU : 명령어를 실행하는 주체
    
## 스택 메모리와 힙 메모리
    
- 스택 - 메서드, 매개변수, 지역변수, 리턴값 등
  - 스택의 경우 함수 호출과 종료에 따라서 스택 메모리가 자동으로 생겼다가 사라지므로, 개발자가 따로 관리할 필요가 없다.
  - 하지만 함수내에서 반복적으로 호출시 스택 메모리가 많이 차게되면 스택오버플로우가 발생할 수 있다.
- 힙 - 매개변수, 지역변수, 인스턴스 변수 등
  - 객체 생성시 heap 영역에 객체가 적재되고 스택 영역에 객체의 참조 주소값이 저장된다.
  - 참조되지 않는 값을 Garbage Collector라고하며 GC가 이루어진다.
    
## 프로그램, 프로세스, 스레드
  - 프로그램
    - 컴퓨터가 실행할 수 있는 명령어들의 집합


  - 프로세스 
    - 컴퓨터에서 실행 중인 프로그램 
    - 각각의 프로세스는 `독립된 메모리 공간`을 할당 받음
    - 명령어들과 데이터를 가짐
  

  - CPU
    - 명령어를 실행하는 연산 장치
  

  - 메인 메모리
    - 프로세스가 CPU에서 실행되기 위해 대기하는 곳
  

  - IO
    - 파일을 읽고 쓰거나 네트워크의 어딘가와 데이터를 주고 받는 것
    - 입출력 장치와 데이터를 주거나 받는 것


  - 스레드
    - 프로세스는 한 개 이상의 스레드를 가질 수 있음
    - CPU에서 실행되는 단위(unit of execution)
    - 같은 프로세스의 스레드들끼리 컨텍스트 스위칭은 가볍다
    - 스레드들은 자신들이 속한 프로세스의 메모리 영역을 공유


  - 멀티프로그래밍
    - CPU 사용률을 극대화 시키기 위함
    - 단점 - CPU 사용 시간이 길어지면 다른 프로세스는 계속 대기
    - 해결책 - 프로세스는 한번 CPU를 사용할때 아주 짧은 시간(=quantum)만 CPU에서 실행되도록 하자


  - 멀티태스킹
    - 아주 짧은 시간동안 cpu를 번갈아가면서 실행하여 즉각즉각 반응하여 동시에 실행되는 것 처럼 보이게 한다.
    - 프로세스의 응답 시간을 최소화 시키는데 목적
    - 단점 - 하나의 프로세스가 동시에 여러 작업을 수행하지는 못함
    - 프로세스의 컨텍스트 스위칭은 무거운 작업
    - 프로세스끼리는 데이터 공유가 까다로움
    - 듀얼 코어가 등장했는데 잘 쓰고 싶음


  - 멀티스레딩
    - 하나의 프로세스가 동시에 여러 작업을 실행하는 데 목적
    - 확장된 멀티태스킹 개념
    - 여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 cpu time을 나눠 갖는 것


  - 멀티프로세싱
    - 두개 이상의 프로세서나 코어를 활용하는 시스템


  - 멀티프로그래밍 : 여러 프로그램들을 동시에 실행할 수 있음. 즉, 여러 프로세스가 존재. 한정적인 CPU 수 보다 프로세스 수가 더 많으면, CPU에서 실행 중이던 프로세스가 I/O 작업을 만나게 되면 다른 프로세스가 CPU에서 실행
  - 멀티태스킹 : 응답성이 안좋을 수 있다는 멀티프로그래밍의 단점을 보완. 즉, 프로세스(혹은 스레드가 CPU 실행의 기본 단위인 오늘날에는 스레드)가 CPU에서 실행될 때 I/O 작업을 만나기 전이라도, 주어진 CPU time slice를 다 쓰게 되면 다른 프로세스(혹은 스레드)가 CPU에서 실행
  - 멀티스레딩 : 하나의 프로세스가 두 개 이상의 스레드를 가지면서 실행되는 방식. (이때부터 CPU에서 실행되는 기본 단위는 프로세스가 아니라 스레드가 됐다고 봐도 무방함)
  - 멀티프로세싱 : 두 개 이상의 CPU나 혹은 싱글 CPU라도 멀티 코어인 경우. 즉, 병렬적으로 실행 가능한 하드웨어인 경우를 의미

## 컨텍스트 스위칭
CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것


- 컨텍스트란 ?
  - 프로세스/스레드의 상태
  - CPU, 메모리 등등


- 컨텍스트 스위칭은 왜 필요한가 ?
  - 여러 프로세스/스레드를 동시에 실행시키기 위해 필요


- 컨텍스트 스위칭은 언제 발생하는가?
  - 주어진 time slice(quantum)를 다 사용했거나
  - IO 작업을 해야되거나
  - 다른 리소스를 기다려야 하거나
  - 등등


- 컨텍스트 스위칭은 누구에 의해 실행되는가 ?
  - OS 커널(kernel)
  - Process Context Switching시에는 가상 메모리 주소 관련 처리를 추가로 수행해야된다.
  - MMU를 변경해야되고, TLB를 비워줘야 하므로 오버헤드가 발생한다.
 


## CPU bound, I/O bound
- CPU
  - 프로세스의 명령어를 해석하고 실행하는 장치
- IO(Input/Output)
  - 파일을 읽고 쓰거나
  - 네트워크의 어딘가와 데이터를 주고 받는 것
  - 입출력 장치와 데이터를 주고 받는 것


- CPU 버스트
  - 프로세스가 CPU에서 한번에 연속적으로 실행되는 시간

  
- IO 버스트
  - 프로세스가 IO 작업을 요청하고 결과를 기다리는 시간


- CPU bound 프로세스 예
  - 동영상 편집 프로그램, 머신러닝 프로그램


- IO bound 프로세스 예
  - (일반적인) 백엔드 API 서버


- CPU bound 프로그램에서 적절한 스레드 수
  - number of CPUs + 1


- IO bound 프로그램에서 적절한 스레드 수
  - thread per request 방식이라면 몇 개의 스레드들을 미리 만들어 놓을지 여러 상황을 고려해서 결정하는 것이 필요

  
## 경쟁조건, 동기화, 임계영역
- 경쟁조건
  - 여러 프로세스/스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황
- 동기화
  - 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것
- 임계 영역
  - 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역
  - critical section problem의 해결책이 되기 위한 조건
    1. mutual exclusion (상호 배제)
    2. progress (진행)
    3. bounded waiting (한정된 대기)

- 해결방법 (lock을 이용하자)
- 스핀락 (spinlock)
  - 락을 가질 수 있을때까지 반복해서 시도
  - 기다리는 동안 CPU를 낭비한다는 단점이 있다.


- 뮤텍스 (Mutex)
  - 락을 가질 수 있을 때 까지 휴식
  - 멀티 코어 환경이고, critical section에서의 작업이 컨텍스트 스위칭보다 더 빨리 끝난다면 스핀락이 뮤텍스보다 더 이점이 있다.
  
- 세마포어 (semaphore)
  - signal mechanism을 가진, 하나 이상의 프로세스/스레드가 critical section에 접근 가능하도록 하는 장치

  
## 데드락(Deadlock)
두 개 이상의 프로세스 혹은 스레드가 서로가 가진 리소스를 기다리는 상태


- 데드락을 만드는 네 가지 조건
  1. Mutual exclusion - 리소스를 공유해서 사용할 수 없다.
  2. Hold and wait - 프로세스가 이미 하나 이상의 리소스를 취득한(hold) 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다린다(wait)
  3. No preemption - 리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있따.
  4. Circular wait - 프로세스들이 순환 형태로 서로의 리소스를 기다린다.


- 데드락 방지
  - 위의 네 가지 조건 중 하나가 충족되지 않게 시스템을 디자인
    1. 리소스를 공유 가능하게 함
    2. 사용할 리소스들을 모두 획득한 뒤에 시작
    3. 리소스를 전혀 가지지 않은 상태에서만 리소스 요청
    4. 추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록 한다
    5. 모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스를 요청


## CPU Scheduler
CPU에서 실행될 프로세스를 선택하는 역할
ready 상태의 프로세스는 ready queue에 적재되어있다.


- Dispatcher
  - 선택된 프로세스에게 CPU를 할당하는 역할
  - Context switching, user mode 전환, 프로세스를 적절한 위치로 이동


- 스케쥴링의 선점 방식
  - Nonpreemptive(비선점) scheduling
    - 프로세스가 자발적으로 자신을 ready 상태로 바꾸는 것
    - 신사적, 협력적, 느린 응답성

  - Preemptive(선점) scheduling
    - running 중인 프로세스를 중단시키고 우선순위가 높은 프로세스가 먼저 실행
    - 적극적, 강제적, 빠른 응답성, 데이터 일관성 문제
 

## 스케쥴링 알고리즘
- FCFS(first-come first-served)
  - 먼저 도착한 순서대로 처리


- SJF(shortest-job-first)
  - 프로세스의 다음 CPU burst가 가장 짧은 프로세스부터 실행


- SRTF(shortest-remaining-time-first)
  - 남은 CPU burst가 가장 짧은 프로세스부터 실행
  - Priority
  - 우선순위가 높은 프로세스부터 실행


- round-robin
  - time slice로 나눠진 CPU time을 번갈아가며 실행


- Multilevel queue
  - 프로세스들을 그룹화해서 그룹마다 큐를 두는 방식

    
## 인터럽트, 시스템 콜 
- User mode
  - 우리가 개발하는 프로그램은 일반적으로 유저 모드에서 실행
  
  
- user mode → kernel mode
  - 프로그램 실행 중에 인터럽트가 발생하거나 시스템 콜을 호출하게 되면 커널 모드로 변환
  
  
- kernel mode
    
  1. 프로그램의 현재 CPU 상태를 저장함
  2. 커널이 인터럽트나 시스템 콜을 직접 처리 (즉, CPU에서 커널 코드가 실행)
        
  3. 처리가 완료되면 중단됐던 프로그램의 CPU 상태를 복원
  4. 다시 통제권을 프로그램에게 반환 kernel → user mode
  5. 프로그램이 이어서 실행됨(user mode)


- 커널(kernel)
  - 운영체제의 핵심
  - 시스템의 전반을 관리/감독하는 역할
  - 하드웨어와 관련된 작업을 직접 수행


- Interrupt
  - 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘
    

- System call
  - 프로그램이 OS 커널이 제공하는 서비스를 이용하고 싶을 때 시스템 콜을 통해 실행
  - 프로세스/스레드 관련, 파일 I/O관련, 소켓 관련, 디바이스 관련, 프로세스 통신 관련

    
## block I/O, non-block I/O
I/O 종류 - network(socket), file, pipe, device

- socket
  - 네트워크 통신은 socket을 통해 데이터가 입출력된다.
  - send_buffer, receive_buffer


- block I/O
  - I/O 작업을 요청한 프로세스/스레드는 요청이 완료될때까지 block된다.


- non-block I/O
  - 프로세스/스레드를 블락시키지 않고 요청에 대한 현재 상태를 즉시 리턴
    
## synchronous/asynchronous
    
- Synchronous programming 
  - 여러 작업(task)들을 순차적으로 실행하도록 개발
  
  
- Asynchronous programming 
  - 여러 작업들을 독립적으로 실행하도록 개발 


## 객체(Object), 클래스(Class)

- 객체 - 상태가 있고 행동을 하는 실체
- 클래스 - 어떠한 속성이 있고 어떻게 행동하는지를 기술한 설계도

```java
// Class
class Car {
  private String name;
  private double speed;
  private Size size;
  ...

  public void accel() {...}
  public void brake() {...}
  ...
}

// Object
Car sonata = new Car();
Car grandure = new Car();
Car santafe = new Car();
``` 

- 내가 원하는 속성과 행동을 구체적으로 기술한 것이 클래스
- 그렇게 기술한대로 실체환 된 것이 객체

## 함수(function)
- 독립적으로 존재하며 임무(task)를 수행하는 코드들의 집합
- 함수 이름으로 호출한다
- 매개 변수(parameter)를 받을 수도 받지 않을 수도 있다.
- 결과 값을 리턴할 수도 하지 않을 수도 있다.
- 재사용이 가능하다

## 메서드(method)
- 객체 혹은 클래스에 종속되어 임무를 수행하는 코드들의 집합
- 클래스나 객체의 상태 정보에 접근도 가능

### Reference
[쉬운코드](https://www.youtube.com/@ez.)
